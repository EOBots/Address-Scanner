import frida
import time
import json
import keyboard  # for global hotkeys, so Endless can stay focused

# ------------ Config ------------
WALK_ADDRESS = "0xEEC70"   # walk function RVA from Endless.exe (from your script)
PRE_BYTES = 0x200          # bytes before X address to include in scan window
SCAN_RANGE = 0x400         # total scan window size in bytes

# Hotkeys to trigger scans while EO window is focused
HOTKEYS = {
    "up": "f9",
    "down": "f10",
    "left": "f11",
    "right": "f12",
}

# ------------ Globals ------------
x_address = None
y_address = None
xstarted = 0

xy_session = None
xy_script = None

scan_session = None
scan_script = None

# store offsets (not absolute) while scanning; we convert to addresses at the end
offset_results = {"up": [], "down": [], "left": [], "right": []}


# ------------ XY resolver (Frida hook, same pattern as your bot) ------------

def on_message_xy(message, data):
    """
    Frida message handler to capture dynamic X/Y addresses when the walk
    function executes once.
    """
    global xstarted, x_address, y_address, xy_session

    if message["type"] == "send":
        payload = message["payload"]
        if "error" in payload:
            print("[frida][xy] error from script:", payload["error"])
            return

        x_address = int(payload["x_address"], 16)
        y_address = int(payload["y_address"], 16)
        print(f"[frida][xy] X={hex(x_address)}, Y={hex(y_address)}")

        xstarted = 1

        # Detach this session once we have X/Y, no need to keep hook active
        try:
            xy_session.detach()
        except Exception:
            pass

    elif message["type"] == "error":
        print("[frida][xy] script error:", message.get("stack", message))


def start_frida_session_xy(walk_address: str):
    """
    Attach to Endless.exe and hook the walk function at WALK_ADDRESS
    to resolve the dynamic X/Y addresses (same logic as CeraBot v12.2/v13).
    """
    global xy_session, xy_script, xstarted

    xstarted = 0
    xy_session = frida.attach("Endless.exe")
    print("[xy] Attached to Endless.exe, waiting for movement hook...")

    # Inline JS, using the same safe pattern as your bot:
    script_code = f"""
    var mod = null;
    try {{
      mod = Process.getModuleByName("Endless.exe");
    }} catch (e) {{
      var mods = Process.enumerateModules();
      mod = mods.length ? mods[0] : null;
    }}

    if (!mod) {{
      throw new Error("Could not find module base for Endless.exe");
    }}

    var base = mod.base;
    var rel  = ptr({int(walk_address, 16)});
    var target = base.add(rel);

    Interceptor.attach(target, {{
      onEnter: function(args) {{
        var reg = this.context.ecx || this.context.rcx;
        if (!reg) {{
          send({{ error: "No ECX/RCX in context" }});
          return;
        }}
        var xAddress = reg.add(0x08);
        var yAddress = xAddress.add(0x04);
        send({{
          x_address: xAddress.toString(),
          y_address: yAddress.toString()
        }});
      }}
    }});
    """

    xy_script = xy_session.create_script(script_code)
    xy_script.on("message", on_message_xy)
    xy_script.load()

    print("[xy] Now MOVE your character once in-game to trigger the walk hook "
          "(keep Endless focused).")

    # Block until we have X/Y
    while xstarted == 0:
        time.sleep(0.01)

    print("[xy] X/Y resolved.")


# ------------ Memory scanner (Frida RPC) ------------

SCAN_JS_TEMPLATE = """
var xPtr = ptr("%s");
var start = xPtr.sub(%d);
var size = %d;

function takeSnapshot() {
    var out = {};
    for (var i = 0; i < size; i++) {
        out[i] = Memory.readU8(start.add(i));
    }
    return out;
}

var baseline = null;

rpc.exports = {
  resetbaseline: function() {
    baseline = takeSnapshot();
  },
  diffscan: function() {
    if (baseline === null) {
      baseline = takeSnapshot();
    }
    var now = takeSnapshot();
    var changed = [];
    for (var i = 0; i < size; i++) {
      if (now[i] !== baseline[i]) {
        changed.push(i);
      }
    }
    return changed;
  }
};
"""


def start_scanner_session():
    """
    Attach a fresh Frida session that exposes:
      - resetbaseline(): capture idle snapshot
      - diffscan(): offsets that differ from baseline
    """
    global scan_session, scan_script

    if x_address is None:
        raise RuntimeError("x_address is not set; run XY hook first.")

    scan_session = frida.attach("Endless.exe")
    js = SCAN_JS_TEMPLATE % (hex(x_address), PRE_BYTES, SCAN_RANGE)
    scan_script = scan_session.create_script(js)
    scan_script.load()
    print("[scan] Scanner script loaded.")

    # ask user to stand still, then capture baseline
    print("\n[scan] Stand still in-game (no movement).")
    input("[scan] When you are idle, press Enter here to capture baseline...")
    scan_script.exports.resetbaseline()
    print("[scan] Idle baseline captured.")


def scan_direction(direction: str, hotkey: str):
    """
    One pass: user focuses Endless Online, holds the arrow key,
    and presses the given HOTKEY (F9/F10/F11/F12). We diff the memory
    against the idle baseline and record the offsets that changed.
    """
    print(f"\n[scan] >>> {direction.upper()} SCAN")
    print(f"[scan] 1) Focus Endless Online window.")
    print(f"[scan] 2) HOLD the {direction.upper()} ARROW key.")
    print(f"[scan] 3) While still holding that arrow, press {hotkey.upper()} once.")
    print(f"[scan] Waiting for {hotkey.upper()}...")

    # Wait for global hotkey while EO stays focused
    keyboard.wait(hotkey)
    # small delay to ensure arrow is being held and memory is in 'moving' state
    time.sleep(0.15)

    changed = scan_script.exports.diffscan()
    offset_results[direction] = changed
    print(f"[scan] {direction.upper()}: {len(changed)} offsets changed vs idle.")


# ------------ Filtering helpers ------------

def compute_absolute_results():
    """
    Convert offset_results into:
      - raw absolute addresses
      - unique absolute addresses (best guesses)
    """
    base_start = x_address - PRE_BYTES

    # Convert offsets to sets for filtering
    sets = {
        d: set(offset_results.get(d, []))
        for d in ("up", "down", "left", "right")
    }

    # raw addresses
    raw_abs = {
        d: [hex(base_start + off) for off in sorted(sets[d])]
        for d in sets
    }

    # unique per-direction: changed for that direction, not for the others
    unique_offsets = {}
    for d in sets:
        other_dirs = [od for od in sets.keys() if od != d]
        others_union = set()
        for od in other_dirs:
            others_union |= sets[od]
        unique_offsets[d] = sets[d] - others_union

    unique_abs = {
        d: [hex(base_start + off) for off in sorted(unique_offsets[d])]
        for d in unique_offsets
    }

    return raw_abs, unique_abs


# ------------ CLI entrypoint ------------

def main():
    print("=== EO Movement Flag Scanner (Frida 16, no GUI, hotkey-triggered) ===")
    print("Make sure Endless.exe is running and your character is in-game.")
    input("Press Enter here once, then switch to Endless and be ready to move...")

    start_frida_session_xy(WALK_ADDRESS)
    print(f"[main] Using resolved X={hex(x_address)}, Y={hex(y_address)}")

    start_scanner_session()

    for direction in ("up", "down", "left", "right"):
        hotkey = HOTKEYS[direction]
        scan_direction(direction, hotkey)

    raw_abs, unique_abs = compute_absolute_results()

    data = {
        "raw": raw_abs,
        "unique": unique_abs
    }

    filename = "movement_addresses.json"
    with open(filename, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=4)

    print(f"\n[done] Saved movement addresses to {filename}")
    print(json.dumps(data, indent=4))

    # Clean up sessions
    if scan_session is not None:
        try:
            scan_session.detach()
        except Exception:
            pass
    if xy_session is not None:
        try:
            xy_session.detach()
        except Exception:
            pass


if __name__ == "__main__":
    main()
