import frida
import time
import json
import ctypes
import ctypes.wintypes as wintypes

# ============================
# CONFIG
# ============================

WALK_ADDRESS = "0xEEC70"   # walk function RVA from Endless.exe (your script)
PRE_BYTES = 0x200          # bytes before X address to include in scan window
SCAN_RANGE = 0x400         # total scan window size in bytes

# Hotkey IDs (arbitrary, just must be unique in this process)
HK_UP = 1
HK_DOWN = 2
HK_LEFT = 3
HK_RIGHT = 4

# Map directions to hotkey IDs and F-keys
DIR_TO_HK = {
    "up":    (HK_UP,    "F9"),
    "down":  (HK_DOWN,  "F10"),
    "left":  (HK_LEFT,  "F11"),
    "right": (HK_RIGHT, "F12"),
}

# ============================
# GLOBAL STATE
# ============================

x_address = None
y_address = None
xstarted = 0

xy_session = None
xy_script = None

scan_session = None
scan_script = None

# store offsets (ints relative to base window); we turn these into absolute
offset_results = {"up": [], "down": [], "left": [], "right": []}

# ============================
# WINDOWS HOTKEY SETUP (WM_HOTKEY)
# ============================

user32 = ctypes.windll.user32
WM_HOTKEY = 0x0312

# Register F9â€“F12 as global hotkeys (no admin required)
# F9  = 0x78
# F10 = 0x79
# F11 = 0x7A
# F12 = 0x7B
user32.RegisterHotKey(None, HK_UP,    0, 0x78)  # F9
user32.RegisterHotKey(None, HK_DOWN,  0, 0x79)  # F10
user32.RegisterHotKey(None, HK_LEFT,  0, 0x7A)  # F11
user32.RegisterHotKey(None, HK_RIGHT, 0, 0x7B)  # F12


def wait_for_hotkey(expected_id: int):
    """
    Block until the WM_HOTKEY with the given ID (wParam) is received.
    Works even if the console is minimized and Endless.exe is focused.
    """
    msg = wintypes.MSG()
    while True:
        # GetMessage blocks until a message is available.
        # Return value:
        #   >0 : message retrieved
        #    0 : WM_QUIT
        #   -1 : error
        ret = user32.GetMessageW(ctypes.byref(msg), None, 0, 0)
        if ret == -1:
            # Error, just continue looping
            continue

        if msg.message == WM_HOTKEY and msg.wParam == expected_id:
            # This is the hotkey we were waiting for
            return

        # For other messages, just do normal translation/dispatch
        user32.TranslateMessage(ctypes.byref(msg))
        user32.DispatchMessageW(ctypes.byref(msg))


# ============================
# XY RESOLVER (Frida hook, same pattern as your bot)
# ============================

def on_message_xy(message, data):
    """
    Frida message handler to capture dynamic X/Y addresses when the walk
    function executes once.
    """
    global xstarted, x_address, y_address, xy_session

    if message["type"] == "send":
        payload = message["payload"]
        if "error" in payload:
            print("[frida][xy] error from script:", payload["error"])
            return

        x_address = int(payload["x_address"], 16)
        y_address = int(payload["y_address"], 16)
        print(f"[frida][xy] X={hex(x_address)}, Y={hex(y_address)}")

        xstarted = 1

        # Detach this session once we have X/Y, no need to keep hook active
        try:
            xy_session.detach()
        except Exception:
            pass

    elif message["type"] == "error":
        print("[frida][xy] script error:", message.get("stack", message))


def start_frida_session_xy(walk_address: str):
    """
    Attach to Endless.exe and hook the walk function at WALK_ADDRESS
    to resolve the dynamic X/Y addresses (same logic as CeraBot v12.2/v13).
    """
    global xy_session, xy_script, xstarted

    xstarted = 0
    xy_session = frida.attach("Endless.exe")
    print("[xy] Attached to Endless.exe, waiting for movement hook...")

    # Inline JS, using the same safe pattern as your bot:
    script_code = f"""
    var mod = null;
    try {{
      mod = Process.getModuleByName("Endless.exe");
    }} catch (e) {{
      var mods = Process.enumerateModules();
      mod = mods.length ? mods[0] : null;
    }}

    if (!mod) {{
      throw new Error("Could not find module base for Endless.exe");
    }}

    var base = mod.base;
    var rel  = ptr({int(walk_address, 16)});
    var target = base.add(rel);

    Interceptor.attach(target, {{
      onEnter: function(args) {{
        var reg = this.context.ecx || this.context.rcx;
        if (!reg) {{
          send({{ error: "No ECX/RCX in context" }});
          return;
        }}
        var xAddress = reg.add(0x08);
        var yAddress = xAddress.add(0x04);
        send({{
          x_address: xAddress.toString(),
          y_address: yAddress.toString()
        }});
      }}
    }});
    """

    xy_script = xy_session.create_script(script_code)
    xy_script.on("message", on_message_xy)
    xy_script.load()

    print("[xy] Now MOVE your character once in-game to trigger the walk hook "
          "(keep Endless focused).")

    # Block until we have X/Y
    while xstarted == 0:
        time.sleep(0.01)

    print("[xy] X/Y resolved.")


# ============================
# MEMORY SCANNER (Frida RPC)
# ============================

SCAN_JS_TEMPLATE = """
var xPtr = ptr("%s");
var start = xPtr.sub(%d);
var size = %d;

function takeSnapshot() {
    var out = {};
    for (var i = 0; i < size; i++) {
        out[i] = Memory.readU8(start.add(i));
    }
    return out;
}

var baseline = null;

rpc.exports = {
  resetbaseline: function() {
    baseline = takeSnapshot();
  },
  diffscan: function() {
    if (baseline === null) {
      baseline = takeSnapshot();
    }
    var now = takeSnapshot();
    var changed = [];
    for (var i = 0; i < size; i++) {
      if (now[i] !== baseline[i]) {
        changed.push(i);
      }
    }
    return changed;
  }
};
"""


def start_scanner_session():
    """
    Attach a fresh Frida session that exposes:
      - resetbaseline(): capture idle snapshot
      - diffscan(): offsets that differ from baseline
    """
    global scan_session, scan_script

    if x_address is None:
        raise RuntimeError("x_address is not set; run XY hook first.")

    scan_session = frida.attach("Endless.exe")
    js = SCAN_JS_TEMPLATE % (hex(x_address), PRE_BYTES, SCAN_RANGE)
    scan_script = scan_session.create_script(js)
    scan_script.load()
    print("[scan] Scanner script loaded.")

    # ask user to stand still, then capture baseline
    print("\n[scan] Stand still in-game (no movement at all).")
    input("[scan] When you are idle, press Enter HERE to capture baseline...")
    scan_script.exports.resetbaseline()
    print("[scan] Idle baseline captured.")


def scan_direction(direction: str):
    """
    One pass: user focuses Endless Online, holds the arrow key for this
    direction, and presses the global hotkey (F9/F10/F11/F12).
    We diff the memory window vs the idle baseline and record the offsets.
    """
    hk_id, hk_name = DIR_TO_HK[direction]

    print(f"\n[scan] >>> {direction.upper()} SCAN")
    print("[scan] 1) Focus Endless Online window.")
    print(f"[scan] 2) HOLD the {direction.upper()} ARROW key (keep it held).")
    print(f"[scan] 3) While still holding it, press {hk_name} once.")
    print(f"[scan] Waiting for {hk_name} hotkey...")

    # Wait for the correct WM_HOTKEY to fire
    wait_for_hotkey(hk_id)

    # small delay to ensure movement is actively happening when we sample
    time.sleep(0.15)

    changed = scan_script.exports.diffscan()
    offset_results[direction] = changed
    print(f"[scan] {direction.upper()}: {len(changed)} offsets changed vs idle.")


# ============================
# FILTERING HELPERS
# ============================

def compute_absolute_results():
    """
    Convert offset_results into:
      - raw absolute addresses
      - unique absolute addresses (best guesses)
    """
    base_start = x_address - PRE_BYTES

    # Convert offsets to sets for filtering
    sets = {
        d: set(offset_results.get(d, []))
        for d in ("up", "down", "left", "right")
    }

    # raw addresses per direction
    raw_abs = {
        d: [hex(base_start + off) for off in sorted(sets[d])]
        for d in sets
    }

    # unique per-direction: changed for that direction, not for the others
    unique_offsets = {}
    for d in sets:
        other_dirs = [od for od in sets.keys() if od != d]
        others_union = set()
        for od in other_dirs:
            others_union |= sets[od]
        unique_offsets[d] = sets[d] - others_union

    unique_abs = {
        d: [hex(base_start + off) for off in sorted(unique_offsets[d])]
        for d in unique_offsets
    }

    return raw_abs, unique_abs


# ============================
# MAIN
# ============================

def main():
    print("=== EO Movement Flag Scanner (Frida 16, WM_HOTKEY global F-keys) ===")
    print("Make sure Endless.exe is running and your character is in-game.")

    input("Press Enter here once, then switch to Endless and be ready to move...")

    start_frida_session_xy(WALK_ADDRESS)
    print(f"[main] Using resolved X={hex(x_address)}, Y={hex(y_address)}")

    start_scanner_session()

    # Run in this fixed order, with clear prompts:
    for direction in ("up", "down", "left", "right"):
        scan_direction(direction)

    raw_abs, unique_abs = compute_absolute_results()

    data = {
        "raw": raw_abs,
        "unique": unique_abs
    }

    filename = "movement_addresses.json"
    with open(filename, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=4)

    print(f"\n[done] Saved movement addresses to {filename}")
    print(json.dumps(data, indent=4))

    # Clean up sessions
    if scan_session is not None:
        try:
            scan_session.detach()
        except Exception:
            pass
    if xy_session is not None:
        try:
            xy_session.detach()
        except Exception:
            pass

    # Unregister hotkeys (cleanup)
    user32.UnregisterHotKey(None, HK_UP)
    user32.UnregisterHotKey(None, HK_DOWN)
    user32.UnregisterHotKey(None, HK_LEFT)
    user32.UnregisterHotKey(None, HK_RIGHT)


if __name__ == "__main__":
    main()
