import time
import json
import pymem
import pymem.process
import pydirectinput


PROCESS_NAME = "Endless.exe"
OUTPUT_FILE = "eo_movement_addresses.json"

# Configure pydirectinput similar to CeraBot usage
pydirectinput.FAILSAFE = False
pydirectinput.PAUSE = 0.02


def attach_process(name: str) -> pymem.Pymem:
    try:
        pm = pymem.Pymem(name)
        return pm
    except pymem.exception.ProcessNotFound:
        raise SystemExit(f"[!] Could not find process '{name}'. Make sure EO is running.")
    except Exception as e:
        raise SystemExit(f"[!] Failed to attach to '{name}': {e}")


def get_main_module(pm: pymem.Pymem):
    try:
        module = pymem.process.module_from_name(pm.process_handle, PROCESS_NAME)
        return module
    except Exception as e:
        raise SystemExit(f"[!] Failed to resolve main module: {e}")


def read_module_bytes(pm: pymem.Pymem, base: int, size: int) -> bytes:
    try:
        return pm.read_bytes(base, size)
    except Exception as e:
        raise SystemExit(f"[!] Failed to read module memory: {e}")


def hold_key(key: str, duration: float = 0.4):
    """
    Hold a *real* movement key like CeraBot does.
    Valid keys here: 'up', 'down', 'left', 'right' (or WASD if you change it).
    """
    pydirectinput.keyDown(key)
    time.sleep(duration)
    pydirectinput.keyUp(key)


def capture_state(pm: pymem.Pymem, base: int, size: int) -> bytes:
    # Small delay to let the game settle
    time.sleep(0.05)
    return read_module_bytes(pm, base, size)


def scan_differences(idle: bytes, states: dict, base: int, step: int = 4) -> dict:
    """
    Compare 4-byte chunks across snapshots and record addresses whose value
    differs from idle for each direction.
    """
    size = min(len(idle), *[len(b) for b in states.values()])
    result = {k: [] for k in states.keys()}

    mv_idle = memoryview(idle)
    mv_states = {k: memoryview(v) for k, v in states.items()}

    for offset in range(0, size - 4, step):
        v_idle = mv_idle[offset:offset + 4]

        for name, mv in mv_states.items():
            v_dir = mv[offset:offset + 4]
            if v_dir != v_idle:
                addr = base + offset
                result[name].append(hex(addr))

    return result


def main():
    print("[*] Attaching to Endless Online...")
    pm = attach_process(PROCESS_NAME)
    module = get_main_module(pm)
    base = module.lpBaseOfDll
    size = module.SizeOfImage

    print(f"[*] Attached to {PROCESS_NAME} at 0x{base:X}, size 0x{size:X}")

    print("\n>>> IMPORTANT <<<")
    print("1) Put your character in a safe place (no monsters, no dialogue).")
    print("2) Focus the Endless Online window.")
    print("3) Do NOT touch keyboard/mouse once scanning starts.")
    print("You have 5 seconds to alt-tab to EO...")
    time.sleep(5.0)

    print("[*] Capturing idle state...")
    idle = capture_state(pm, base, size)

    directions = [
        ("up", "up"),
        ("down", "down"),
        ("left", "left"),
        ("right", "right"),
    ]

    states = {}

    for label, key in directions:
        print(f"[*] Moving {label} (sending real arrow key: {key})...")
        # Hold key briefly, capture, then release
        pydirectinput.keyDown(key)
        time.sleep(0.15)
        snap = capture_state(pm, base, size)
        pydirectinput.keyUp(key)

        states[label] = snap
        time.sleep(0.5)  # let game settle between moves

    print("[*] Scanning for differences...")
    result = scan_differences(idle, states, base, step=4)

    with open(OUTPUT_FILE, "w", encoding="utf-8") as f:
        json.dump(result, f, indent=4)

    print(f"[+] Scan complete. Candidate addresses saved to {OUTPUT_FILE}")
    for k, v in result.items():
        print(f"  {k}: {len(v)} addresses")


if __name__ == "__main__":
    main()
