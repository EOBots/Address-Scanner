import frida
import time
import json

# ------------ Config ------------
WALK_ADDRESS = "0xEEC70"   # walk function RVA from Endless.exe
PRE_BYTES = 0x200          # bytes before X address to include in scan window
SCAN_RANGE = 0x400         # total scan window size in bytes

# ------------ Globals ------------
x_address = None
y_address = None
xstarted = 0

xy_session = None
xy_script = None

scan_session = None
scan_script = None

results = {"up": [], "down": [], "left": [], "right": []}


# ------------ XY resolver (Frida hook, same pattern as CeraBot) ------------

def on_message_xy(message, data):
    """
    Frida message handler to capture dynamic X/Y addresses when the walk
    function executes once.
    """
    global xstarted, x_address, y_address, xy_session

    if message["type"] == "send":
        payload = message["payload"]
        if "error" in payload:
            print("[frida][xy] error from script:", payload["error"])
            return

        x_address = int(payload["x_address"], 16)
        y_address = int(payload["y_address"], 16)
        print(f"[frida][xy] X={hex(x_address)}, Y={hex(y_address)}")

        xstarted = 1

        # Detach this session once we have X/Y, no need to keep hook active
        try:
            xy_session.detach()
        except Exception:
            pass

    elif message["type"] == "error":
        print("[frida][xy] script error:", message.get("stack", message))


def start_frida_session_xy(walk_address: str):
    """
    Attach to Endless.exe and hook the walk function at WALK_ADDRESS
    to resolve the dynamic X/Y addresses (same logic as CeraBot v12.2/v13).
    """
    global xy_session, xy_script, xstarted

    xstarted = 0
    xy_session = frida.attach("Endless.exe")
    print("[xy] Attached to Endless.exe, waiting for movement hook...")

    # Inline JS, using the same safe pattern as your bot:
    script_code = f"""
    var mod = null;
    try {{
      mod = Process.getModuleByName("Endless.exe");
    }} catch (e) {{
      var mods = Process.enumerateModules();
      mod = mods.length ? mods[0] : null;
    }}

    if (!mod) {{
      throw new Error("Could not find module base for Endless.exe");
    }}

    var base = mod.base;
    var rel  = ptr({int(walk_address, 16)});
    var target = base.add(rel);

    Interceptor.attach(target, {{
      onEnter: function(args) {{
        var reg = this.context.ecx || this.context.rcx;
        if (!reg) {{
          send({{ error: "No ECX/RCX in context" }});
          return;
        }}
        var xAddress = reg.add(0x08);
        var yAddress = xAddress.add(0x04);
        send({{
          x_address: xAddress.toString(),
          y_address: yAddress.toString()
        }});
      }}
    }});
    """

    xy_script = xy_session.create_script(script_code)
    xy_script.on("message", on_message_xy)
    xy_script.load()

    print("[xy] Now move your character once in-game to trigger the walk hook...")

    # Block until we have X/Y
    while xstarted == 0:
        time.sleep(0.01)

    print("[xy] X/Y resolved.")


# ------------ Memory scanner (Frida RPC) ------------

SCAN_JS_TEMPLATE = """
var xPtr = ptr("%s");
var start = xPtr.sub(%d);
var size = %d;

function takeSnapshot() {
    var out = {};
    for (var i = 0; i < size; i++) {
        out[i] = Memory.readU8(start.add(i));
    }
    return out;
}

var snapshot = takeSnapshot();

rpc.exports = {
  diffscan: function() {
    var now = takeSnapshot();
    var changed = [];
    for (var i = 0; i < size; i++) {
      if (now[i] !== snapshot[i]) {
        changed.push(i);
      }
    }
    snapshot = now;
    return changed;
  }
};
"""


def start_scanner_session():
    """
    Attach a fresh Frida session that exposes diffscan(), which returns
    offsets inside [x_address-PRE_BYTES, x_address-PRE_BYTES+SCAN_RANGE)
    that changed since the last snapshot.
    """
    global scan_session, scan_script

    if x_address is None:
        raise RuntimeError("x_address is not set; run XY hook first.")

    scan_session = frida.attach("Endless.exe")
    js = SCAN_JS_TEMPLATE % (hex(x_address), PRE_BYTES, SCAN_RANGE)
    scan_script = scan_session.create_script(js)
    scan_script.load()
    print("[scan] Scanner script loaded. Baseline snapshot captured.")


def scan_direction(direction: str):
    """
    One pass: user holds UP/DOWN/LEFT/RIGHT in EO, we diff the memory
    window and record all changed absolute addresses for that direction.
    """
    print(f"\n[scan] >>> Prepare to scan {direction.upper()} movement.")
    print(f"[scan] Hold the {direction.upper()} key in Endless Online, then press Enter here.")
    input()
    time.sleep(0.2)  # small delay to make sure state is 'held'

    changed = scan_script.exports.diffscan()
    base_start = x_address - PRE_BYTES
    abs_addrs = [hex(base_start + off) for off in changed]
    results[direction] = abs_addrs

    print(f"[scan] {direction.upper()}: {len(abs_addrs)} changed addresses recorded.")


# ------------ CLI entrypoint ------------

def main():
    print("=== EO Movement Flag Scanner (Frida 16, no GUI) ===")
    print("Make sure Endless.exe is running and your character is in-game.")
    input("Press Enter to attach and resolve X/Y using walkAddress hook...")

    start_frida_session_xy(WALK_ADDRESS)
    print(f"[main] Using resolved X={hex(x_address)}, Y={hex(y_address)}")

    start_scanner_session()

    for direction in ("up", "down", "left", "right"):
        scan_direction(direction)

    filename = "movement_addresses.json"
    with open(filename, "w", encoding="utf-8") as f:
        json.dump(results, f, indent=4)

    print(f"\n[done] Saved absolute movement addresses to {filename}")
    print(json.dumps(results, indent=4))

    # Clean up sessions
    if scan_session is not None:
        try:
            scan_session.detach()
        except Exception:
            pass
    if xy_session is not None:
        try:
            xy_session.detach()
        except Exception:
            pass


if __name__ == "__main__":
    main()
